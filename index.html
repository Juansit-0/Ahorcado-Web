<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Juego del Ahorcado - Documentaci칩n</title>
<link rel="stylesheet" href="styles.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollToPlugin.min.js"></script>
</head>
<body>
<header class="header">
<nav class="nav">
<div class="nav-brand">
<h1>游꿡 Juego del Ahorcado</h1>
</div>
<div class="nav-links">
<a href="#requirements" class="nav-link">Requerimientos</a>
<a href="#flowchart" class="nav-link">Diagrama</a>
<a href="#classes" class="nav-link">Clases</a>
</div>
</nav>
</header>

<section class="hero">
<div class="hero-content">
<h1 class="hero-title">Juego del Ahorcado</h1>
<p class="hero-subtitle">Documentaci칩n t칠cnica y an치lisis de implementaci칩n</p>
<div class="hero-stats">
<div class="stat-item">
<span class="stat-number">3</span>
<span class="stat-label">Clases</span>
</div>
<div class="stat-item">
<span class="stat-number">9</span>
<span class="stat-label">Requerimientos</span>
</div>
<div class="stat-item">
<span class="stat-number">1</span>
<span class="stat-label">Profe Dani</span>
</div>
</div>
</div>
<div class="hero-visual">
<div class="floating-code">
<pre><code class="python-code"> El que lea esto, que su mam치 le dure
</code></pre>
</div>
</div>
</section>

<section id="requirements" class="section">
<div class="container">
<h2 class="section-title">Requerimientos Funcionales</h2>
<div class="table-container">
<table class="requirements-table">
<thead>
<tr>
<th>Nombre</th>
<th>Descripci칩n</th>
<th>Entradas</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr class="table-row">
<td>R1. Iniciar Partida de Ahorcado</td>
<td>Permite al usuario comenzar un nuevo juego del Ahorcado. Al iniciar, se muestra una fila de guiones representando la palabra a adivinar y el jugador comienza con 6 intentos.</td>
<td><span class="priority low">Ninguna</span></td>
<td><span class="status completed">Se prepara el tablero de juego con guiones, se inicializan los intentos a 6, y la partida se establece como activa</span></td>
</tr>
<tr class="table-row">
<td>R2. Escoger y Validar Letra</td>
<td>El jugador debe poder ingresar una letra.</td>
<td><span class="priority low">Una letra del alfabeto</span></td>
<td><span class="status completed">
    Si la letra est치 en la palabra: la letra se muestra en sus posiciones correspondientes sobre los guiones.
    Si la letra no est치 en la palabra: se descuenta un intento y se actualiza la representaci칩n gr치fica del ahorcado.
    Si la letra ya fue utilizada: se notifica al jugador.</span></td>
</tr>
<tr class="table-row">
<td>R3. Visualizar Resultado de la Jugada y Final de Partida</td>
<td>Muestra el resultado de cada intento y gestiona el final del juego.</td>
<td><span class="priority low">Estado actual del juego (intentos restantes, palabra adivinada, estado de victoria/derrota).</span></td>
<td><span class="status completed">
    Durante el juego: Se actualiza la visualizaci칩n de la palabra (guiones/letras adivinadas) y el dibujo del ahorcado.
    Fin de partida por derrota: Si los intentos llegan a cero, se notifica al jugador que ha sido "ahorcado", se muestra la gr치fica final del ahorcado y no se permiten m치s jugadas.
    Fin de partida por victoria: Si el jugador adivina la palabra completa, se le felicita y no se permiten m치s jugadas.</span></td>
</tr>
<tr class="table-row">
<td>R4. Mostrar la Palabra Oculta</td>
<td>Presenta al usuario la palabra que debe adivinar, mostrando los guiones para las letras no descubiertas y las letras correctas en sus posiciones.</td>
<td><span class="priority low">La palabra secreta y las letras adivinadas hasta el momento</span></td>
<td><span class="status completed">Una representaci칩n visual de la palabra, e.g., "P _ T _ N".</span></td>
</tr>
<tr class="table-row">
<td>R5. Mostrar Intentos Restantes</td>
<td>Informa al jugador cu치ntas oportunidades le quedan antes de perder el juego.</td>
<td><span class="priority low">El n칰mero actual de intentos disponibles</span></td>
<td><span class="status completed">Un contador num칠rico visible de los intentos restantes</span></td>
</tr>
<tr class="table-row">
<td>R6. Mostrar Letras Ya Usadas</td>
<td>Muestra una lista de todas las letras que el jugador ya ha intentado, tanto correctas como incorrectas.</td>
<td><span class="priority low">La colecci칩n de letras que ya han sido jugadas</span></td>
<td><span class="status completed">Una lista o conjunto de caracteres que el jugador ya ha ingresado</span></td>
</tr>
<tr class="table-row">
<td>R7. Mostrar Dibujo del Ahorcado</td>
<td>Actualiza la representaci칩n visual del ahorcado, a침adiendo una parte por cada intento incorrecto.</td>
<td><span class="priority low">El n칰mero de intentos incorrectos (o intentos restantes).</span></td>
<td><span class="status completed">Un dibujo incremental del ahorcado</span></td>
</tr>
<tr class="table-row">
<td>R8. Validar Formato de Entrada de Letra</td>
<td>Asegura que la entrada del usuario sea exactamente una sola letra del alfabeto y la convierte a un formato consistente (ej. min칰scula).</td>
<td><span class="priority low">La cadena de caracteres ingresada por el usuario</span></td>
<td><span class="status completed">La letra validada y formateada si es correcta; un mensaje de error si no lo es</span></td>
</tr>
<tr class="table-row">
<td>R9. Gesti칩n de Reinicio de Partida</td>
<td>Permite que todas las variables del juego (palabra, intentos, letras usadas) se restablezcan a su estado inicial para una nueva partida.</td>
<td><span class="priority low">Solicitud para reiniciar (ej. bot칩n "Nueva Partida").</span></td>
<td><span class="status completed">El juego vuelve a un estado inicial listo para comenzar una nueva partida.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>

<section id="flowchart" class="section">
<div class="container">
<h2 class="section-title">Diagrama de Flujo del Juego</h2>
<div class="flowchart-container">
<img src="foto.png" alt="Diagrama de Clases del Juego del Ahorcado" class="diagram-image">
</div>
</div>
</section>

<section id="classes" class="section">
<div class="container">
<h2 class="section-title">Estructura de Clases</h2>
<div class="classes-grid">
<div class="class-card">
<div class="class-header">
<span class="class-name">JuegoAhorcado</span>
<span class="class-type">Clase Principal</span>
</div>
<div class="class-description">
<p>Clase principal que controla la l칩gica del juego. Gestiona el estado del juego, los intentos disponibles y coordina la interacci칩n con otras clases.</p>
<div class="code-container">
<pre><code class="python-code">class JuegoAhorcado:
"""
Clase principal que controla la l칩gica del juego Ahorcado.
Gestiona el estado del juego, los intentos disponibles y coordina
la interacci칩n con las clases Palabra y Letra.
"""
def __init__(self, diccionario: list['Palabra']):
self.diccionario: list['Palabra'] = diccionario
self.palabra_actual: 'Palabra' = None
self.intentos_disponibles: int = 6 # Seis intentos como m치ximo
self.jugadas: list['Letra'] = [] # Lista de letras intentadas
self.estado: EstadoJuego = EstadoJuego.NO_INICIADO # Estado inicial

def iniciar_juego(self) -> None:
"""
Inicia una nueva partida de Ahorcado.
Selecciona una palabra aleatoria del diccionario, resetea intentos y jugadas,
y establece el estado del juego a JUGANDO.
"""
import random
self.palabra_actual = random.choice(self.diccionario)
self.intentos_disponibles = 6
self.jugadas = []
self.estado = EstadoJuego.JUGANDO

def jugar_letra(self, letra: 'Letra') -> None:
"""
Procesa la jugada de una letra por parte del usuario.
Verifica si la letra ya fue utilizada, la agrega a las jugadas,
actualiza los intentos si la letra es incorrecta y determina
las condiciones de victoria o derrota del juego.
"""
if self.estado != EstadoJuego.JUGANDO:
print("El juego no est치 en curso. Inicia una nueva partida.")
return

if self.letra_utilizada(letra):
print(f"La letra '{letra.dar_letra()}' ya ha sido utilizada.")
return

self.jugadas.append(letra)

if not self.palabra_actual.esta_letra(letra):
self.intentos_disponibles -= 1
print(f"Letra incorrecta. Intentos restantes: {self.intentos_disponibles}")
else:
print(f"춰Letra correcta! '{letra.dar_letra()}' est치 en la palabra.")

self._actualizar_estado_juego()

def _actualizar_estado_juego(self) -> None:
"""
Actualiza el estado del juego (GANADOR, AHORCADO o JUGANDO)
bas치ndose en el progreso actual.
"""
if self.palabra_actual.esta_completa(self.jugadas):
self.estado = EstadoJuego.GANADOR
print("춰Felicidades! Has adivinado la palabra. 춰Has ganado!")
elif self.intentos_disponibles <= 0:
self.estado = EstadoJuego.AHORCADO
print(f"춰Oh no! Te has quedado sin intentos. La palabra era: {self.palabra_actual.dar_letras_como_string()}")
else:
self.estado = EstadoJuego.JUGANDO # Se mantiene jugando si no ha ganado ni perdido

def dar_palabra_actual(self) -> 'Palabra':
"""Retorna la palabra actual del juego."""
return self.palabra_actual

def dar_palabra(self, posicion: int) -> 'Palabra':
"""Retorna una palabra del diccionario en la posici칩n dada."""
if 0 <= posicion < len(self.diccionario):
return self.diccionario[posicion]
return None

def dar_intentos_disponibles(self) -> int:
"""Retorna el n칰mero de intentos disponibles restantes."""
return self.intentos_disponibles

def dar_jugadas(self) -> list['Letra']:
"""Retorna una copia de las letras ya jugadas."""
return list(self.jugadas)

def dar_ocurrencias(self) -> list[str]:
"""
Retorna la representaci칩n actual de la palabra con letras adivinadas
y guiones bajos para las no adivinadas (ej. ['H', '_', 'L', '_']).
"""
if self.palabra_actual:
return self.palabra_actual.dar_ocurrencias(self.jugadas)
return []

def dar_estado(self) -> 'EstadoJuego':
"""Retorna el estado actual del juego."""
return self.estado

def letra_utilizada(self, letra: 'Letra') -> bool:
"""Verifica si una letra ya ha sido utilizada en la partida actual."""
return any(l.es_igual(letra) for l in self.jugadas)

# Definici칩n de Enum para el estado del juego (requiere Python 3.4+)
from enum import Enum

class EstadoJuego(Enum):
NO_INICIADO = "No Iniciado"
JUGANDO = "Jugando"
GANADOR = "Ganador"
AHORCADO = "Ahorcado"

</code></pre>
</div>
</div>
</div>

<div class="class-card">
<div class="class-header">
<span class="class-name">Letra</span>
<span class="class-type">Clase Auxiliar</span>
</div>
<div class="class-description">
<p>Representa una letra individual en el juego, manejando comparaciones sin distinci칩n de may칰sculas y min칰sculas.</p>
<div class="code-container">
<pre><code class="python-code">class Letra:
"""
Representa una letra individual en el juego del Ahorcado.
Maneja la letra como un car치cter 칰nico y permite comparaciones
sin distinci칩n de may칰sculas y min칰sculas.
"""
def __init__(self, letra: str):
if not isinstance(letra, str) or len(letra) != 1 or not letra.isalpha():
raise ValueError("Letra debe ser un 칰nico car치cter alfab칠tico.")
self.letra: str = letra.lower() # Almacenar en min칰scula para consistencia

def dar_letra(self) -> str:
"""Retorna el car치cter de la letra."""
return self.letra

def es_igual(self, otra_letra: 'Letra') -> bool:
"""
Compara si esta letra es igual a otra, sin importar may칰sculas/min칰sculas.
"""
if not isinstance(otra_letra, Letra):
return False
return self.letra == otra_letra.dar_letra()

def __eq__(self, other):
"""Permite la comparaci칩n con == """
if not isinstance(other, Letra):
return NotImplemented
return self.es_igual(other)

def __hash__(self):
"""Permite que los objetos Letra sean usados en sets/dicts"""
return hash(self.letra)

def __str__(self):
return self.letra

def __repr__(self):
return f"Letra('{self.letra}')"
</code></pre>
</div>
</div>
</div>

<div class="class-card">
<div class="class-header">
<span class="class-name">Palabra</span>
<span class="class-type">Clase Auxiliar</span>
</div>
<div class="class-description">
<p>Representa una palabra del juego, compuesta por objetos <code>Letra</code>. Encargada de validar si la palabra ha sido completamente adivinada y de mostrar las ocurrencias de las letras.</p>
<div class="code-container">
<pre><code class="python-code">class Palabra:
"""
Representa una palabra en el juego del Ahorcado.
Compuesta por una secuencia de objetos Letra.
Encargada de validar si la palabra ha sido completamente adivinada
y de mostrar las ocurrencias de las letras adivinadas.
"""
def __init__(self, palabra_str: str):
if not isinstance(palabra_str, str) or not palabra_str.isalpha():
raise ValueError("Palabra debe ser una cadena de caracteres alfab칠ticos.")
self.letras: list['Letra'] = [Letra(c) for c in palabra_str]

def esta_completa(self, p_jugadas: list['Letra']) -> bool:
"""
Verifica si la palabra ha sido completamente adivinada
bas치ndose en las letras jugadas por el usuario.
"""
return all(self._buscar_letra_en_lista(l, p_jugadas) for l in self.letras)

def _buscar_letra_en_lista(self, p_letra: 'Letra', lista_letras: list['Letra']) -> bool:
"""
M칠todo auxiliar privado para verificar si una Letra est치 presente
en una lista de objetos Letra.
"""
return any(l.es_igual(p_letra) for l in lista_letras)

def esta_letra(self, p_letra: 'Letra') -> bool:
"""Verifica si una letra dada est치 presente en la palabra."""
return self._buscar_letra_en_lista(p_letra, self.letras)

def dar_ocurrencias(self, p_jugadas: list['Letra']) -> list[str]:
"""
Retorna una lista de caracteres, mostrando las letras adivinadas
y '_' para las letras a칰n no adivinadas de la palabra.
"""
return [l.dar_letra() if self._buscar_letra_en_lista(l, p_jugadas) else '_' for l in self.letras]

def dar_letras(self) -> list['Letra']:
"""Retorna la lista de objetos Letra que componen la palabra."""
return list(self.letras) # Retorna una copia para evitar modificaci칩n externa

def dar_letras_como_string(self) -> str:
"""Retorna la palabra completa como una cadena de texto."""
return "".join(l.dar_letra() for l in self.letras)

def __str__(self):
return self.dar_letras_como_string()

def __repr__(self):
return f"Palabra('{self.dar_letras_como_string()}')"
</code></pre>
</div>
</div>
</div>
</div>
</div>
</section>

<footer class="footer">
<div class="container">
<p>&copy; 2024 Juego del Ahorcado. Todos los derechos reservados.</p>
</div>
</footer>

<script>
gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

// Header animation on scroll
gsap.to(".header", {
background: "rgba(10, 10, 10, 0.9)",
backdropFilter: "blur(10px)",
boxShadow: "0 2px 10px rgba(0,0,0,0.5)",
duration: 0.3,
ease: "power1.out",
scrollTrigger: {
trigger: "body",
start: "top -=100",
end: "top -=100",
scrub: true
}
});

// Hero section animations
gsap.from(".hero-title", { duration: 1, y: 50, opacity: 0, ease: "power3.out", delay: 0.5 });
gsap.from(".hero-subtitle", { duration: 1, y: 50, opacity: 0, ease: "power3.out", delay: 0.7 });
gsap.from(".hero-stats .stat-item", { duration: 1, y: 50, opacity: 0, stagger: 0.2, ease: "power3.out", delay: 0.9 });
gsap.from(".hero-visual", { duration: 1, x: 100, opacity: 0, ease: "power3.out", delay: 1.1 });

// Floating code animation
gsap.to(".floating-code", {
y: -10,
repeat: -1,
yoyo: true,
ease: "sine.inOut",
duration: 2
});

// Section title animations
gsap.utils.toArray(".section-title").forEach(title => {
gsap.from(title, {
opacity: 0,
y: 50,
duration: 1,
ease: "power2.out",
scrollTrigger: {
trigger: title,
start: "top 80%",
toggleActions: "play none none reverse"
}
});
});

// Table row and card animations
gsap.utils.toArray(".table-row, .class-card").forEach(element => {
gsap.from(element, {
opacity: 0,
y: 20,
duration: 0.8,
ease: "power1.out",
scrollTrigger: {
trigger: element,
start: "top 85%",
toggleActions: "play none none reverse"
}
});
});

// Nav link hover
document.querySelectorAll('.nav-link').forEach(link => {
link.addEventListener('mouseenter', () => {
gsap.to(link, {
duration: 0.3,
color: "var(--primary-color)",
y: -3,
textShadow: "0 0 10px rgba(0, 255, 136, 0.5)"
});
});
link.addEventListener('mouseleave', () => {
gsap.to(link, {
duration: 0.3,
color: "var(--text-primary)",
y: 0,
textShadow: "none"
});
});
});

// Class card hover
document.querySelectorAll('.class-card').forEach(card => {
card.addEventListener('mouseenter', () => {
gsap.to(card, {
duration: 0.3,
scale: 1.02,
boxShadow: "0 15px 40px rgba(0, 255, 136, 0.2)",
y: -5,
ease: "power2.out"
});
});
card.addEventListener('mouseleave', () => {
gsap.to(card, {
duration: 0.3,
scale: 1,
y: 0,
boxShadow: "0 10px 30px rgba(0, 0, 0, 0.3)",
ease: "power2.out"
});
});
});

// Table row hover
document.querySelectorAll('.table-row').forEach(row => {
row.addEventListener('mouseenter', () => {
gsap.to(row, { duration: 0.3, backgroundColor: "rgba(0, 255, 136, 0.1)" });
});
row.addEventListener('mouseleave', () => {
gsap.to(row, { duration: 0.3, backgroundColor: "transparent" });
});
});

// Smooth scrolling for navigation links
document.querySelectorAll('.nav-link').forEach(link => {
link.addEventListener('click', (e) => {
e.preventDefault();
const target = document.querySelector(link.getAttribute('href'));
if (target) {
gsap.to(window, {
duration: 1,
scrollTo: { y: target, offsetY: 80 },
ease: "power3.inOut"
});
}
});
});

// Parallax effect for hero section
gsap.to(".hero-visual", {
yPercent: -50,
ease: "none",
scrollTrigger: {
trigger: ".hero",
start: "top bottom",
end: "bottom top",
scrub: true
}
});
</script>
</body>
</html>